<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šåŠŸèƒ½æ–‡æœ¬åŠ å¯†è§£å¯†å™¨</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            width: 100%;
            max-width: 1100px;
            padding: 30px;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 2.2em;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 25px;
            font-size: 1.1em;
        }
        
        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .mode-tab {
            padding: 12px 30px;
            border: 2px solid #667eea;
            border-radius: 25px;
            background: white;
            color: #667eea;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .mode-tab.active {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }
        
        .mode-content {
            display: none;
        }
        
        .mode-content.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* æ–‡æœ¬æ¡†æ¨¡å¼æ ·å¼ */
        .text-input-container {
            margin-bottom: 25px;
        }
        
        .input-label {
            display: block;
            margin-bottom: 8px;
            color: #34495e;
            font-weight: 600;
            font-size: 1.1em;
        }
        
        .text-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            font-family: 'Microsoft YaHei', 'Segoe UI', sans-serif;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
            min-height: 200px;
            resize: vertical;
        }
        
        .text-input:focus {
            outline: none;
                    border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }
        
        /* æ–‡ä»¶ä¸Šä¼ æ¨¡å¼æ ·å¼ */
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 10px;
            padding: 40px 20px;
            text-align: center;
            margin-bottom: 25px;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9ff;
        }
        
        .upload-area:hover {
            background: #f0f2ff;
            border-color: #764ba2;
        }
        
        .upload-area.highlight {
            background: #e8edff;
            border-color: #4CAF50;
        }
        
        .upload-icon {
            font-size: 48px;
            color: #667eea;
            margin-bottom: 15px;
        }
        
        .upload-text {
            font-size: 18px;
            color: #333;
            margin-bottom: 10px;
        }
        
        .upload-hint {
            font-size: 14px;
            color: #666;
            margin-bottom: 20px;
        }
        
        .upload-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s;
        }
        
        .upload-btn:hover {
            background: #764ba2;
            transform: translateY(-2px);
        }
        
        /* é€šç”¨æ ·å¼ */
        .capacity-info {
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: center;
            font-size: 16px;
        }
        
        .file-info {
            background: #f0f7ff;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            display: none;
        }
        
        .file-info.show {
            display: block;
        }
        
        .file-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
            word-break: break-all;
        }
        
        .file-size {
            color: #666;
            font-size: 14px;
        }
        
        .content-type {
            background: #fff3cd;
            padding: 8px 12px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 13px;
            color: #856404;
            border-left: 3px solid #ffc107;
            display: none;
        }
        
        .content-type.detected {
            display: block;
        }
        
        .content-type.text {
            background: #e8f5e9;
            border-left-color: #4CAF50;
            color: #2E7D32;
        }
        
        .content-type.encrypted {
            background: #e3f2fd;
            border-left-color: #2196F3;
            color: #1565C0;
        }
        
        .content-preview {
            font-size: 13px;
            color: #888;
            margin: 5px 0;
            font-style: italic;
        }
        
        .encoding-container {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            display: none;
        }
        
        .encoding-container.show {
            display: block;
        }
        
        .encoding-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .encoding-header h4 {
            margin: 0;
            color: #2c3e50;
        }
        
        .encoding-selector {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background: white;
            font-size: 14px;
            margin-top: 10px;
        }
        
        .encoding-selector:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .encoding-hint {
            font-size: 13px;
            color: #666;
            margin-top: 8px;
            padding: 8px;
            background: #fff3cd;
            border-radius: 4px;
            border-left: 3px solid #ffc107;
        }
        
        .encoding-auto {
            background: #e8f5e9;
            border-left: 3px solid #4CAF50;
        }
        
        /* æŒ‰é’®ç»„ */
        .button-group {
            display: flex;
            gap: 15px;
            margin: 25px 0;
            flex-wrap: wrap;
        }
        
        button {
            flex: 1;
            min-width: 180px;
            padding: 14px 20px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .encrypt-btn {
            background: linear-gradient(to right, #667eea, #764ba2);
            color: white;
        }
        
        .decrypt-btn {
            background: linear-gradient(to right, #4CAF50, #2E7D32);
            color: white;
        }
        
        .auto-btn {
            background: linear-gradient(to right, #FF9800, #F57C00);
            color: white;
        }
        
        .clear-btn {
            background: linear-gradient(to right, #f44336, #c62828);
            color: white;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* è¿›åº¦æ¡ */
        .progress-container {
            margin: 25px 0;
            display: none;
        }
        
        .progress-container.show {
            display: block;
        }
        
        .progress-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
            color: #666;
        }
        
        .progress {
            width: 100%;
            height: 12px;
            background: #e0e0e0;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.3s;
        }
        
        /* ç»“æœåŒºåŸŸ */
        .result-area {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            margin-top: 25px;
            display: none;
        }
        
        .result-area.show {
            display: block;
            animation: fadeIn 0.5s ease;
        }
        
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .result-header h3 {
            color: #2c3e50;
            margin: 0;
            font-size: 1.4em;
        }
        
        .result-actions {
            display: flex;
            gap: 10px;
        }
        
        .download-btn, .copy-btn {
            background: #5a67d8;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.3s;
            text-decoration: none;
        }
        
        .copy-btn {
            background: #4CAF50;
        }
        
        .download-btn:hover, .copy-btn:hover {
            transform: translateY(-2px);
        }
        
        .download-btn:hover {
            background: #4c51bf;
        }
        
        .copy-btn:hover {
            background: #388E3C;
        }
        
        .copy-btn.copied {
            background: #2E7D32;
        }
        
        .result-content {
            font-family: 'Microsoft YaHei', 'Segoe UI', sans-serif;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.6;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            max-height: 300px;
            overflow-y: auto;
            font-size: 14px;
            margin-top: 15px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .stat-item {
            background: white;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            background: #4CAF50;
            color: white;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateX(100px);
            transition: all 0.3s;
            z-index: 1000;
        }
        
        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }
        
        .performance-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 14px;
            display: none;
        }
        
        .performance-warning.show {
            display: block;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.8em;
            }
            
            .mode-selector {
                flex-direction: column;
                align-items: center;
            }
            
            .mode-tab {
                width: 100%;
                text-align: center;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            button {
                min-width: 100%;
            }
            
            .result-actions {
                flex-direction: column;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” å†·ç‹¼æ–‡æœ¬åŠ å¯†è§£å¯†å™¨</h1>
        <p class="subtitle">å®ˆæŠ¤å¤§å®¶å…±åŒçš„çˆ±å¥½ï¼</p>
        
        <div class="capacity-info">
            ğŸ’ª æ”¯æŒæ–‡æœ¬è¾“å…¥å’Œæ–‡ä»¶ä¸Šä¼ ä¸¤ç§æ¨¡å¼ | æ”¹è¿›çš„ç¼–ç æ£€æµ‹ | è¶…å¤§æ–‡ä»¶å¤„ç†  | æ”¯æŒå¤šç¼–ç æ ¼å¼
        </div>
        
        <!-- æ¨¡å¼é€‰æ‹© -->
        <div class="mode-selector">
            <div class="mode-tab active" onclick="switchMode('text')">ğŸ“ æ–‡æœ¬è¾“å…¥æ¨¡å¼</div>
            <div class="mode-tab" onclick="switchMode('file')">ğŸ“ æ–‡ä»¶ä¸Šä¼ æ¨¡å¼</div>
        </div>
        
        <!-- æ–‡æœ¬è¾“å…¥æ¨¡å¼ -->
        <div class="mode-content active" id="textMode">
            <div class="text-input-container">
                <label class="input-label" for="textInput">è¾“å…¥æ–‡æœ¬ï¼š</label>
                <textarea class="text-input" id="textInput" placeholder="åœ¨æ­¤è¾“å…¥éœ€è¦åŠ å¯†æˆ–è§£å¯†çš„æ–‡æœ¬..."></textarea>
            </div>
            
            <div class="button-group">
                <button class="encrypt-btn" onclick="processText('encrypt')" id="textEncryptBtn">
                    ğŸ”’ åŠ å¯†æ–‡æœ¬
                </button>
                <button class="decrypt-btn" onclick="processText('decrypt')" id="textDecryptBtn">
                    ğŸ”“ è§£å¯†æ–‡æœ¬
                </button>
                <button class="auto-btn" onclick="autoProcessText()" id="textAutoBtn">
                    ğŸ¤– è‡ªåŠ¨å¤„ç†
                </button>
                <button class="clear-btn" onclick="clearText()">
                    ğŸ—‘ï¸ æ¸…ç©ºæ–‡æœ¬
                </button>
            </div>
        </div>
        
        <!-- æ–‡ä»¶ä¸Šä¼ æ¨¡å¼ -->
        <div class="mode-content" id="fileMode">
            <!-- æ–‡ä»¶ä¸Šä¼ åŒºåŸŸ -->
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">ğŸ“</div>
                <div class="upload-text">ç‚¹å‡»é€‰æ‹©æ–‡ä»¶ï¼Œæˆ–æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤åŒºåŸŸ</div>
                <div class="upload-hint">æ”¯æŒTXTæ–‡æœ¬æ–‡ä»¶ï¼Œæœ€å¤§50MB</div>
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    ğŸ“¤ é€‰æ‹©æ–‡ä»¶
                </button>
                <input type="file" id="fileInput" accept=".txt" style="display: none;">
            </div>
            
            <!-- æ€§èƒ½è­¦å‘Š -->
            <div class="performance-warning" id="performanceWarning">
                âš ï¸ æ–‡ä»¶è¾ƒå¤§ï¼Œå¤„ç†å¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´ï¼Œè¯·è€å¿ƒç­‰å¾…...
            </div>
            
            <!-- å†…å®¹ç±»å‹æ£€æµ‹ -->
            <div class="content-type" id="contentType">
                æ­£åœ¨æ£€æµ‹æ–‡ä»¶ç±»å‹...
            </div>
            
            <!-- ç¼–ç æ£€æµ‹åŒºåŸŸ -->
            <div class="encoding-container" id="encodingContainer">
                <div class="encoding-header">
                    <h4>ğŸ“Š ç¼–ç æ£€æµ‹ç»“æœ</h4>
                </div>
                
                <div id="encodingHint" class="encoding-hint encoding-auto">
                    æ­£åœ¨æ£€æµ‹æ–‡ä»¶ç¼–ç ...
                </div>
                
                <select class="encoding-selector" id="encodingSelector" onchange="applyEncoding(this.value)">
                    <option value="">è¯·é€‰æ‹©ç¼–ç ...</option>
                    <option value="UTF-8">UTF-8 (æ¨è)</option>
                    <option value="GBK">GBK (ç®€ä½“ä¸­æ–‡)</option>
                    <option value="GB18030">GB18030</option>
                    <option value="Big5">Big5 (ç¹ä½“ä¸­æ–‡)</option>
                    <option value="UTF-16LE">UTF-16LE</option>
                    <option value="UTF-16BE">UTF-16BE</option>
                    <option value="Shift_JIS">Shift_JIS (æ—¥æ–‡)</option>
                    <option value="EUC-JP">EUC-JP (æ—¥æ–‡)</option>
                    <option value="ISO-8859-1">ISO-8859-1 (è¥¿æ¬§)</option>
                </select>
            </div>
            
            <!-- æ–‡ä»¶ä¿¡æ¯ -->
            <div class="file-info" id="fileInfo">
                <div class="file-name" id="fileName"></div>
                <div class="file-size" id="fileSize"></div>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">å­—ç¬¦æ•°</div>
                        <div class="stat-value" id="charCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">æ–‡ä»¶å¤§å°</div>
                        <div class="stat-value" id="byteCount">0 KB</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">æ£€æµ‹ç¼–ç </div>
                        <div class="stat-value" id="detectedEncoding">æœªçŸ¥</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">æ–‡ä»¶ç±»å‹</div>
                        <div class="stat-value" id="fileType">æœªçŸ¥</div>
                    </div>
                </div>
            </div>
            
            <div class="content-preview" id="contentPreview" style="display: none;">
                å†…å®¹é¢„è§ˆï¼ˆå‰1000å­—ç¬¦ï¼‰:
            </div>
            
            <!-- æ–‡ä»¶å†…å®¹é¢„è§ˆ -->
            <textarea class="text-input" id="fileContent" placeholder="æ–‡ä»¶å†…å®¹å°†åœ¨è¿™é‡Œæ˜¾ç¤º..." style="display: none;"></textarea>
            
            <div class="button-group">
                <button class="encrypt-btn" onclick="processFile('encrypt')" id="fileEncryptBtn">
                    ğŸ”’ åŠ å¯†æ–‡ä»¶
                </button>
                <button class="decrypt-btn" onclick="processFile('decrypt')" id="fileDecryptBtn">
                    ğŸ”“ è§£å¯†æ–‡ä»¶
                </button>
                <button class="auto-btn" onclick="autoProcessFile()" id="fileAutoBtn">
                    ğŸ¤– è‡ªåŠ¨å¤„ç†
                </button>
                <button class="clear-btn" onclick="clearFile()">
                    ğŸ—‘ï¸ æ¸…é™¤æ–‡ä»¶
                </button>
            </div>
        </div>
        
        <!-- è¿›åº¦æ¡ -->
        <div class="progress-container" id="progressContainer">
            <div class="progress-info">
                <span id="progressText">å‡†å¤‡å¤„ç†...</span>
                <span id="progressPercent">0%</span>
            </div>
            <div class="progress">
                <div class="progress-bar" id="progressBarFill"></div>
            </div>
        </div>
        
        <!-- ç»“æœåŒºåŸŸ -->
        <div class="result-area" id="resultArea">
            <div class="result-header">
                <h3>å¤„ç†å®Œæˆï¼</h3>
                <div class="result-actions">
                    <a class="download-btn" id="downloadLink" download="result.txt">
                        â¬‡ï¸ ä¸‹è½½æ–‡ä»¶
                    </a>
                    <button class="copy-btn" onclick="copyResult()" id="copyResultBtn">
                        ğŸ“‹ å¤åˆ¶ç»“æœ
                    </button>
                </div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">å¤„ç†æ–¹å¼</div>
                    <div class="stat-value" id="processType">-</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">å¤„ç†æ—¶é—´</div>
                    <div class="stat-value" id="processTime">0 ç§’</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">ç»“æœå¤§å°</div>
                    <div class="stat-value" id="resultSize">0 å­—ç¬¦</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">è¾“å…¥æ¨¡å¼</div>
                    <div class="stat-value" id="inputMode">æ–‡æœ¬</div>
                </div>
            </div>
            
            <div class="content-preview">ç»“æœé¢„è§ˆ:</div>
            <div class="result-content" id="resultContent">
                ç»“æœå°†åœ¨è¿™é‡Œæ˜¾ç¤º...
            </div>
        </div>
		<div id="" style="font-size: 12px;">
			<div id="">
				âš ï¸ å…è´£å£°æ˜
			</div>
			æœ¬å·¥å…·ä¸ºæŠ€æœ¯æ¼”ç¤ºå’Œå­¦ä¹ æ•™è‚²ç”¨é€”ï¼Œæ‰€æœ‰æ“ä½œå‡åœ¨ç”¨æˆ·æœ¬åœ°æµè§ˆå™¨å®Œæˆï¼Œæ•°æ®ä¸ä¼šä¸Šä¼ åˆ°ä»»ä½•æœåŠ¡å™¨ã€‚ç”¨æˆ·éœ€ç¡®ä¿å¤„ç†çš„å†…å®¹å‡ä¸ºåˆæ³•è‡ªæœ‰å†…å®¹ï¼Œä¸å¾—ç”¨äºä»»ä½•éæ³•æˆ–ä¾µæƒç”¨é€”ã€‚æœ¬å·¥å…·æŒ‰"ç°çŠ¶"æä¾›ï¼Œä¸ä¿è¯100%æ— é”™è¯¯æˆ–ç»å¯¹å®‰å…¨ï¼Œå¼€å‘è€…å¯¹å› ä½¿ç”¨æœ¬å·¥å…·äº§ç”Ÿçš„ä»»ä½•ç›´æ¥æˆ–é—´æ¥æŸå¤±ä¸æ‰¿æ‹…è´£ä»»ã€‚ä½¿ç”¨æœ¬å·¥å…·å³è¡¨ç¤ºæ‚¨å·²é˜…è¯»ã€ç†è§£å¹¶åŒæ„æœ¬å…è´£å£°æ˜ã€‚
		</div>
    </div>

    <!-- é€šçŸ¥ -->
    <div class="notification" id="notification">
        <span id="notificationText">æ“ä½œæˆåŠŸï¼</span>
    </div>
	
    <script>
        const FIXED_KEY = "multi-mode-encryption-2024";
        const MAX_FILE_SIZE = 50 * 1024 * 1024;
        let currentMode = 'text';
        let currentFile = null;
        let fileContent = '';
        let fileRawData = null;
        let currentEncoding = 'UTF-8';
        let detectedEncoding = 'æœªçŸ¥';
        let isEncryptedFile = false;
        
        // æ˜¾ç¤ºé€šçŸ¥
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            const notificationText = document.getElementById('notificationText');
            
            notificationText.textContent = message;
            
            if (type === 'success') {
                notification.style.background = '#4CAF50';
            } else if (type === 'error') {
                notification.style.background = '#f44336';
            } else if (type === 'warning') {
                notification.style.background = '#FF9800';
            }
            
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
        
        // æ›´æ–°è¿›åº¦æ˜¾ç¤º
        function updateProgress(percent, text = '') {
            const progressFill = document.getElementById('progressBarFill');
            const progressPercent = document.getElementById('progressPercent');
            const progressText = document.getElementById('progressText');
            
            progressFill.style.width = percent + '%';
            progressPercent.textContent = percent + '%';
            
            if (text) {
                progressText.textContent = text;
            }
        }
        
        // æ˜¾ç¤º/éšè—è¿›åº¦æ¡
        function showProgress(show = true) {
            const progressContainer = document.getElementById('progressContainer');
            if (show) {
                progressContainer.classList.add('show');
                updateProgress(0, 'å‡†å¤‡å¤„ç†...');
            } else {
                setTimeout(() => {
                    progressContainer.classList.remove('show');
                    updateProgress(0, 'å‡†å¤‡å¤„ç†...');
                }, 500);
            }
        }
        
        // åˆ‡æ¢æ¨¡å¼
        function switchMode(mode) {
            currentMode = mode;
            
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            document.querySelectorAll('.mode-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(mode + 'Mode').classList.add('active');
            
            document.getElementById('resultArea').classList.remove('show');
            
            showNotification(`åˆ‡æ¢åˆ°${mode === 'text' ? 'æ–‡æœ¬è¾“å…¥' : 'æ–‡ä»¶ä¸Šä¼ '}æ¨¡å¼`, 'success');
        }
        
        // ä¼˜åŒ–çš„Base64ç¼–ç 
        function arrayToBase64(array) {
            const chunkSize = 32768;
            let result = '';
            
            for (let i = 0; i < array.length; i += chunkSize) {
                const chunk = array.slice(i, i + chunkSize);
                result += String.fromCharCode.apply(null, chunk);
            }
            
            return btoa(result);
        }
        
        // ä¼˜åŒ–çš„Base64è§£ç 
        function base64ToArray(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            
            return bytes;
        }
        
        // åˆ¤æ–­æ˜¯å¦æ˜¯åŠ å¯†æ–‡æœ¬
        function isEncryptedText(text) {
            if (!text || text.length < 50) return false;
            
            try {
                // Base64æ ¼å¼æ£€æŸ¥
                const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
                const isBase64 = base64Regex.test(text);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰å¸¸è§çš„éBase64å­—ç¬¦
                const hasInvalidChars = /[^A-Za-z0-9+/=]/.test(text);
                
                // æ£€æŸ¥é•¿åº¦æ˜¯å¦èƒ½è¢«4æ•´é™¤ï¼ˆBase64è¦æ±‚ï¼‰
                const lengthValid = text.length % 4 === 0;
                
                // æ£€æŸ¥æ˜¯å¦æœ‰æ˜æ˜¾çš„ä¸­æ–‡å­—ç¬¦ï¼ˆå¦‚æœæ˜¯ä¸­æ–‡æ–‡æœ¬ï¼Œå°±ä¸æ˜¯Base64ï¼‰
                const hasChineseChars = /[\u4e00-\u9fa5]/.test(text);
                
                // å¦‚æœæ˜¯Base64æ ¼å¼ã€æ²¡æœ‰æ— æ•ˆå­—ç¬¦ã€é•¿åº¦æœ‰æ•ˆã€æ²¡æœ‰ä¸­æ–‡å­—ç¬¦ï¼Œå°±å¯èƒ½æ˜¯åŠ å¯†æ–‡æœ¬
                return isBase64 && !hasInvalidChars && lengthValid && !hasChineseChars;
            } catch {
                return false;
            }
        }
        
        // æ£€æµ‹æ–‡ä»¶å†…å®¹ç±»å‹
        function detectContentType(buffer) {
            try {
                const bytes = new Uint8Array(buffer);
                const sampleSize = Math.min(bytes.length, 4096);
                const sampleBytes = bytes.slice(0, sampleSize);
                
                // å°è¯•ç”¨UTF-8è§£ç 
                try {
                    const decoder = new TextDecoder('utf-8');
                    const text = decoder.decode(sampleBytes);
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯åŠ å¯†æ–‡æœ¬ï¼ˆBase64ï¼‰
                    if (isEncryptedText(text)) {
                        return { type: 'encrypted', confidence: 95 };
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯æ™®é€šæ–‡æœ¬
                    const asciiRatio = (text.match(/[\x00-\x7F]/g) || []).length / text.length;
                    const chineseRatio = (text.match(/[\u4e00-\u9fa5]/g) || []).length / text.length;
                    
                    if (chineseRatio > 0.1 || asciiRatio > 0.7) {
                        return { type: 'text', confidence: 90 };
                    }
                } catch (e) {
                    // UTF-8è§£ç å¤±è´¥
                }
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶ï¼ˆéæ–‡æœ¬ï¼‰
                let nonTextBytes = 0;
                for (let i = 0; i < sampleSize; i++) {
                    const byte = sampleBytes[i];
                    // æ§åˆ¶å­—ç¬¦ï¼ˆé™¤äº†åˆ¶è¡¨ç¬¦ã€æ¢è¡Œã€å›è½¦ï¼‰
                    if (byte < 32 && byte !== 9 && byte !== 10 && byte !== 13) {
                        nonTextBytes++;
                    }
                }
                
                if (nonTextBytes / sampleSize > 0.1) {
                    return { type: 'binary', confidence: 80 };
                }
                
                return { type: 'unknown', confidence: 0 };
            } catch (error) {
                return { type: 'unknown', confidence: 0 };
            }
        }
        
        // æ”¹è¿›çš„ç¼–ç æ£€æµ‹ç®—æ³•ï¼ˆç‰¹åˆ«å¤„ç†åŠ å¯†æ–‡æœ¬ï¼‰
        function detectEncoding(buffer) {
            const bytes = new Uint8Array(buffer);
            const sampleSize = Math.min(bytes.length, 4096);
            const sampleBytes = bytes.slice(0, sampleSize);
            
            // 1. æ£€æŸ¥BOM
            if (sampleBytes[0] === 0xEF && sampleBytes[1] === 0xBB && sampleBytes[2] === 0xBF) {
                return { encoding: 'UTF-8', confidence: 100, hasBOM: true };
            }
            if (sampleBytes[0] === 0xFF && sampleBytes[1] === 0xFE) {
                return { encoding: 'UTF-16LE', confidence: 100, hasBOM: true };
            }
            if (sampleBytes[0] === 0xFE && sampleBytes[1] === 0xFF) {
                return { encoding: 'UTF-16BE', confidence: 100, hasBOM: true };
            }
            
            // 2. ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæ˜¯åŠ å¯†æ–‡æœ¬ï¼ˆBase64ï¼‰ï¼Œç›´æ¥è¿”å›UTF-8
            try {
                const decoder = new TextDecoder('utf-8');
                const text = decoder.decode(sampleBytes);
                if (isEncryptedText(text)) {
                    // åŠ å¯†æ–‡æœ¬æ€»æ˜¯ä½¿ç”¨UTF-8ç¼–ç 
                    return { encoding: 'UTF-8', confidence: 95, hasBOM: false, isEncrypted: true };
                }
            } catch (e) {
                // å¿½ç•¥è§£ç é”™è¯¯
            }
            
            // 3. ç»Ÿè®¡ä¸åŒç¼–ç çš„å¯èƒ½æ€§
            let utf8Score = 0;
            let gbkScore = 0;
            let utf16leScore = 0;
            let asciiOnly = true;
            
            for (let i = 0; i < sampleBytes.length; i++) {
                const byte = sampleBytes[i];
                
                // æ£€æŸ¥ASCIIå­—ç¬¦
                if (byte < 0x80) {
                    continue;
                }
                
                asciiOnly = false;
                
                // UTF-8å¤šå­—èŠ‚åºåˆ—æ£€æŸ¥
                if ((byte & 0xE0) === 0xC0) { // 2å­—èŠ‚UTF-8
                    if (i + 1 < sampleBytes.length && (sampleBytes[i + 1] & 0xC0) === 0x80) {
                        utf8Score += 3;
                        i++;
                    }
                } else if ((byte & 0xF0) === 0xE0) { // 3å­—èŠ‚UTF-8
                    if (i + 2 < sampleBytes.length && 
                        (sampleBytes[i + 1] & 0xC0) === 0x80 && 
                        (sampleBytes[i + 2] & 0xC0) === 0x80) {
                        utf8Score += 4;
                        i += 2;
                    }
                } else if ((byte & 0xF8) === 0xF0) { // 4å­—èŠ‚UTF-8
                    if (i + 3 < sampleBytes.length && 
                        (sampleBytes[i + 1] & 0xC0) === 0x80 && 
                        (sampleBytes[i + 2] & 0xC0) === 0x80 && 
                        (sampleBytes[i + 3] & 0xC0) === 0x80) {
                        utf8Score += 5;
                        i += 3;
                    }
                }
                
                // GBKä¸­æ–‡æ£€æŸ¥
                if (byte >= 0x81 && byte <= 0xFE) {
                    if (i + 1 < sampleBytes.length) {
                        const nextByte = sampleBytes[i + 1];
                        if ((nextByte >= 0x40 && nextByte <= 0x7E) || 
                            (nextByte >= 0x80 && nextByte <= 0xFE)) {
                            gbkScore += 2;
                            i++;
                        }
                    }
                }
                
                // UTF-16LEæ£€æŸ¥ï¼ˆé˜²æ­¢è¯¯åˆ¤Base64ä¸ºUTF-16LEï¼‰
                if (byte === 0x00 && i + 1 < sampleBytes.length) {
                    const nextByte = sampleBytes[i + 1];
                    if (nextByte !== 0x00 && nextByte < 0x80) {
                        utf16leScore += 1;
                    }
                }
            }
            
            // 4. å¦‚æœæ˜¯çº¯ASCIIï¼Œè¿”å›UTF-8
            if (asciiOnly) {
                return { encoding: 'UTF-8', confidence: 90, hasBOM: false };
            }
            
            // 5. é˜²æ­¢UTF-16LEè¯¯åˆ¤
            // å¦‚æœæ˜¯Base64æ–‡æœ¬ï¼ŒUTF-16LEåˆ†æ•°å¯èƒ½åé«˜ï¼Œä½†å®é™…åº”è¯¥æ˜¯UTF-8
            const total = utf8Score + gbkScore;
            let encoding, confidence;
            
            if (utf8Score > gbkScore * 1.5 && utf8Score > utf16leScore * 2) {
                encoding = 'UTF-8';
                confidence = Math.round((utf8Score / total) * 100);
            } else if (gbkScore > utf8Score * 1.5) {
                encoding = 'GBK';
                confidence = Math.round((gbkScore / total) * 100);
            } else if (utf16leScore > utf8Score * 3 && utf16leScore > gbkScore * 3) {
                // åªæœ‰UTF-16LEåˆ†æ•°æ˜¾è‘—é«˜äºå…¶ä»–ç¼–ç æ—¶æ‰é€‰æ‹©
                encoding = 'UTF-16LE';
                confidence = Math.round((utf16leScore / (utf16leScore + 1)) * 100);
            } else {
                // éš¾ä»¥åˆ¤æ–­ï¼Œå°è¯•è§£ç æµ‹è¯•
                encoding = 'UTF-8'; // é»˜è®¤UTF-8
                confidence = 50;
            }
            
            return { 
                encoding: encoding, 
                confidence: Math.min(confidence, 95), 
                hasBOM: false 
            };
        }
        
        // å°è¯•ç”¨å¤šç§ç¼–ç è§£ç ï¼ˆæ”¹è¿›ç‰ˆï¼‰
        function tryDecodeWithMultipleEncodings(buffer) {
            const encodings = [
                'UTF-8',
                'GBK',
                'GB18030',
                'Big5',
                'Shift_JIS',
                'EUC-JP',
                'ISO-8859-1'
            ];
            
            // å…ˆæ£€æŸ¥æ˜¯å¦æ˜¯åŠ å¯†æ–‡æœ¬ï¼ˆBase64ï¼‰
            try {
                const utf8Decoder = new TextDecoder('utf-8');
                const text = utf8Decoder.decode(buffer.slice(0, Math.min(buffer.byteLength, 1000)));
                if (isEncryptedText(text)) {
                    // åŠ å¯†æ–‡æœ¬æ€»æ˜¯ä½¿ç”¨UTF-8
                    return {
                        encoding: 'UTF-8',
                        text: utf8Decoder.decode(buffer),
                        chineseRatio: 0,
                        garbageRatio: 0,
                        isValid: true,
                        isEncrypted: true
                    };
                }
            } catch (e) {
                // å¿½ç•¥é”™è¯¯
            }
            
            const results = [];
            
            for (const encoding of encodings) {
                try {
                    const decoder = new TextDecoder(encoding);
                    const text = decoder.decode(buffer);
                    
                    if (text && text.length > 0) {
                        // ç»Ÿè®¡ä¸­æ–‡å­—ç¬¦æ•°é‡
                        const chineseCharCount = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
                        const totalChars = text.length;
                        const chineseRatio = totalChars > 0 ? chineseCharCount / totalChars : 0;
                        
                        // æ£€æŸ¥ä¹±ç å­—ç¬¦
                        const garbageCount = (text.match(/[ï¿½]/g) || []).length;
                        const garbageRatio = totalChars > 0 ? garbageCount / totalChars : 0;
                        
                        // æ£€æŸ¥æ˜¯å¦æ˜¯åŠ å¯†æ–‡æœ¬ï¼ˆå¦‚æœæ˜¯ï¼Œä¹±ç æ£€æµ‹ä¸é€‚ç”¨ï¼‰
                        const isEncrypted = isEncryptedText(text);
                        
                        results.push({
                            encoding: encoding,
                            text: text,
                            chineseRatio: chineseRatio,
                            garbageRatio: garbageRatio,
                            isValid: garbageRatio < 0.05 || isEncrypted,
                            isEncrypted: isEncrypted
                        });
                    }
                } catch (e) {
                    // è¯¥ç¼–ç æ— æ³•è§£ç ï¼Œè·³è¿‡
                }
            }
            
            // æ’åºè§„åˆ™ï¼šä¼˜å…ˆé€‰æ‹©æœ‰æ•ˆã€éåŠ å¯†ã€ä¸­æ–‡æ¯”ä¾‹é«˜ã€ä¹±ç å°‘çš„
            results.sort((a, b) => {
                // ä¼˜å…ˆæœ‰æ•ˆç»“æœ
                if (a.isValid !== b.isValid) return b.isValid - a.isValid;
                
                // å¦‚æœæ˜¯åŠ å¯†æ–‡æœ¬ï¼Œä¼˜å…ˆUTF-8
                if (a.isEncrypted && b.isEncrypted) {
                    if (a.encoding === 'UTF-8') return -1;
                    if (b.encoding === 'UTF-8') return 1;
                }
                
                // éåŠ å¯†æ–‡æœ¬ï¼Œä¼˜å…ˆä¸­æ–‡æ¯”ä¾‹é«˜çš„
                if (!a.isEncrypted && !b.isEncrypted) {
                    if (Math.abs(a.chineseRatio - b.chineseRatio) > 0.1) {
                        return b.chineseRatio - a.chineseRatio;
                    }
                    return a.garbageRatio - b.garbageRatio;
                }
                
                // å…¶ä»–æƒ…å†µä¿æŒåŸé¡ºåº
                return 0;
            });
            
            return results.length > 0 ? results[0] : null;
        }
        
        // åŠ å¯†å‡½æ•°
        async function aesEncryptLarge(text, password) {
            try {
                updateProgress(10, 'æ­£åœ¨å‡†å¤‡åŠ å¯†...');
                
                const encoder = new TextEncoder();
                const passwordKey = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(password),
                    { name: 'PBKDF2' },
                    false,
                    ['deriveBits', 'deriveKey']
                );
                
                updateProgress(20, 'æ­£åœ¨ç”Ÿæˆå¯†é’¥...');
                const salt = crypto.getRandomValues(new Uint8Array(16));
                const iv = crypto.getRandomValues(new Uint8Array(12));
                
                const key = await crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: salt,
                        iterations: 100000,
                        hash: 'SHA-256'
                    },
                    passwordKey,
                    { name: 'AES-GCM', length: 256 },
                    false,
                    ['encrypt']
                );
                
                updateProgress(40, 'æ­£åœ¨åŠ å¯†æ•°æ®...');
                const encrypted = await crypto.subtle.encrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv
                    },
                    key,
                    encoder.encode(text)
                );
                
                updateProgress(70, 'æ­£åœ¨è½¬æ¢æ ¼å¼...');
                const encryptedBytes = new Uint8Array(encrypted);
                const combined = new Uint8Array(salt.length + iv.length + encryptedBytes.length);
                combined.set(salt);
                combined.set(iv, salt.length);
                combined.set(encryptedBytes, salt.length + iv.length);
                
                updateProgress(90, 'æ­£åœ¨ç”Ÿæˆæœ€ç»ˆç»“æœ...');
                const base64Result = arrayToBase64(combined);
                
                updateProgress(100, 'åŠ å¯†å®Œæˆï¼');
                return base64Result;
                
            } catch (error) {
                console.error('åŠ å¯†é”™è¯¯:', error);
                throw error;
            }
        }
        
        // è§£å¯†å‡½æ•°
        async function aesDecryptLarge(encryptedBase64, password) {
            try {
                updateProgress(10, 'æ­£åœ¨å‡†å¤‡è§£å¯†...');
                
                updateProgress(30, 'æ­£åœ¨è§£ç æ•°æ®...');
                const combined = base64ToArray(encryptedBase64);
                
                updateProgress(40, 'æ­£åœ¨æå–å¯†é’¥ä¿¡æ¯...');
                const salt = combined.slice(0, 16);
                const iv = combined.slice(16, 28);
                const encrypted = combined.slice(28);
                
                const encoder = new TextEncoder();
                const passwordKey = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(password),
                    { name: 'PBKDF2' },
                    false,
                    ['deriveKey']
                );
                
                updateProgress(60, 'æ­£åœ¨æ´¾ç”Ÿå¯†é’¥...');
                const key = await crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: salt,
                        iterations: 100000,
                        hash: 'SHA-256'
                    },
                    passwordKey,
                    { name: 'AES-GCM', length: 256 },
                    false,
                    ['decrypt']
                );
                
                updateProgress(80, 'æ­£åœ¨è§£å¯†æ•°æ®...');
                const decrypted = await crypto.subtle.decrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv
                    },
                    key,
                    encrypted
                );
                
                updateProgress(90, 'æ­£åœ¨è§£ç æ–‡æœ¬...');
                const result = new TextDecoder().decode(decrypted);
                
                updateProgress(100, 'è§£å¯†å®Œæˆï¼');
                return result;
                
            } catch (error) {
                console.error('è§£å¯†é”™è¯¯:', error);
                throw error;
            }
        }
        
        // ================= æ–‡æœ¬æ¨¡å¼åŠŸèƒ½ =================
        
        async function processText(mode) {
            const text = document.getElementById('textInput').value.trim();
            
            if (!text) {
                showNotification('âŒ è¯·è¾“å…¥è¦å¤„ç†çš„æ–‡æœ¬', 'error');
                return;
            }
            
            try {
                document.getElementById('textEncryptBtn').disabled = true;
                document.getElementById('textDecryptBtn').disabled = true;
                document.getElementById('textAutoBtn').disabled = true;
                showProgress();
                
                const startTime = Date.now();
                let result;
                
                if (mode === 'encrypt') {
                    result = await aesEncryptLarge(text, FIXED_KEY);
                } else {
                    if (!isEncryptedText(text)) {
                        throw new Error('è¿™ä¸æ˜¯æœ‰æ•ˆçš„åŠ å¯†æ–‡æœ¬');
                    }
                    result = await aesDecryptLarge(text, FIXED_KEY);
                }
                
                const endTime = Date.now();
                const processTime = ((endTime - startTime) / 1000).toFixed(2);
                
                showResult(result, mode, processTime, 'text');
                
                showNotification(`âœ… ${mode === 'encrypt' ? 'åŠ å¯†' : 'è§£å¯†'}æˆåŠŸï¼`, 'success');
                
            } catch (error) {
                showNotification(`âŒ ${mode === 'encrypt' ? 'åŠ å¯†' : 'è§£å¯†'}å¤±è´¥ï¼š${error.message}`, 'error');
            } finally {
                document.getElementById('textEncryptBtn').disabled = false;
                document.getElementById('textDecryptBtn').disabled = false;
                document.getElementById('textAutoBtn').disabled = false;
                showProgress(false);
            }
        }
        
        function autoProcessText() {
            const text = document.getElementById('textInput').value.trim();
            
            if (!text) {
                showNotification('âŒ è¯·è¾“å…¥è¦å¤„ç†çš„æ–‡æœ¬', 'error');
                return;
            }
            
            if (isEncryptedText(text)) {
                processText('decrypt');
            } else {
                processText('encrypt');
            }
        }
        
        function clearText() {
            document.getElementById('textInput').value = '';
            document.getElementById('resultArea').classList.remove('show');
            showNotification('ğŸ—‘ï¸ å·²æ¸…ç©ºæ–‡æœ¬æ¡†', 'success');
        }
        
        // ================= æ–‡ä»¶æ¨¡å¼åŠŸèƒ½ =================
        
        function initDragAndDrop() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            uploadArea.addEventListener('click', (e) => {
                if (e.target !== fileInput) {
                    fileInput.click();
                }
            });
            
            fileInput.addEventListener('change', handleFileSelect);
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, preventDefaults, false);
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            ['dragenter', 'dragover'].forEach(eventName => {
                uploadArea.addEventListener(eventName, () => {
                    uploadArea.classList.add('highlight');
                }, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, () => {
                    uploadArea.classList.remove('highlight');
                }, false);
            });
            
            uploadArea.addEventListener('drop', handleDrop, false);
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            }
        }
        
        function handleFileSelect(e) {
            const files = e.target.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        }
        
        async function handleFile(file) {
            if (!file.name.toLowerCase().endsWith('.txt')) {
                showNotification('âŒ è¯·é€‰æ‹©TXTæ–‡æœ¬æ–‡ä»¶', 'error');
                return;
            }
            
            if (file.size > MAX_FILE_SIZE) {
                showNotification(`âŒ æ–‡ä»¶è¿‡å¤§ï¼ˆ${(file.size/1024/1024).toFixed(1)}MBï¼‰ï¼Œæœ€å¤§æ”¯æŒ50MB`, 'error');
                return;
            }
            
            currentFile = file;
            
            if (file.size > 5 * 1024 * 1024) {
                document.getElementById('performanceWarning').classList.add('show');
            }
            
            showNotification(`ğŸ“„ æ­£åœ¨åŠ è½½æ–‡ä»¶... (${(file.size/1024/1024).toFixed(1)}MB)`, 'success');
            
            try {
                fileRawData = await file.arrayBuffer();
                await analyzeAndDecodeFile(fileRawData);
                
            } catch (error) {
                console.error('æ–‡ä»¶è¯»å–å¤±è´¥:', error);
                showNotification('âŒ æ–‡ä»¶è¯»å–å¤±è´¥ï¼š' + error.message, 'error');
            }
        }
        
        async function analyzeAndDecodeFile(buffer) {
            try {
                // æ˜¾ç¤ºå†…å®¹ç±»å‹æ£€æµ‹
                const contentTypeElement = document.getElementById('contentType');
                contentTypeElement.classList.add('detected');
                contentTypeElement.textContent = 'æ­£åœ¨æ£€æµ‹æ–‡ä»¶ç±»å‹...';
                
                // æ˜¾ç¤ºç¼–ç æ£€æµ‹å®¹å™¨
                const encodingContainer = document.getElementById('encodingContainer');
                encodingContainer.classList.add('show');
                
                const encodingHint = document.getElementById('encodingHint');
                encodingHint.textContent = 'æ­£åœ¨æ£€æµ‹æ–‡ä»¶ç¼–ç ...';
                encodingHint.className = 'encoding-hint encoding-auto';
                
                // 1. æ£€æµ‹å†…å®¹ç±»å‹
                updateProgress(20, 'æ­£åœ¨æ£€æµ‹æ–‡ä»¶ç±»å‹...');
                const contentTypeResult = detectContentType(buffer);
                
                // æ›´æ–°å†…å®¹ç±»å‹æ˜¾ç¤º
                let contentTypeText = '';
                let contentTypeClass = '';
                
                if (contentTypeResult.type === 'encrypted') {
                    contentTypeText = 'ğŸ” æ£€æµ‹åˆ°åŠ å¯†æ–‡ä»¶ï¼ˆBase64æ ¼å¼ï¼‰';
                    contentTypeClass = 'encrypted';
                    isEncryptedFile = true;
                } else if (contentTypeResult.type === 'text') {
                    contentTypeText = 'ğŸ“„ æ£€æµ‹åˆ°æ™®é€šæ–‡æœ¬æ–‡ä»¶';
                    contentTypeClass = 'text';
                    isEncryptedFile = false;
                } else if (contentTypeResult.type === 'binary') {
                    contentTypeText = 'âš ï¸ æ£€æµ‹åˆ°å¯èƒ½æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶ï¼ˆéçº¯æ–‡æœ¬ï¼‰';
                    contentTypeClass = '';
                } else {
                    contentTypeText = 'â“ æ— æ³•ç¡®å®šæ–‡ä»¶ç±»å‹';
                    contentTypeClass = '';
                }
                
                contentTypeElement.textContent = contentTypeText;
                contentTypeElement.className = `content-type detected ${contentTypeClass}`;
                
                // 2. æ£€æµ‹ç¼–ç ï¼ˆç‰¹åˆ«å¤„ç†åŠ å¯†æ–‡ä»¶ï¼‰
                updateProgress(40, 'æ­£åœ¨æ£€æµ‹ç¼–ç ...');
                
                let finalEncoding = 'UTF-8';
                let finalText = '';
                let confidence = 0;
                
                if (isEncryptedFile) {
                    // åŠ å¯†æ–‡ä»¶æ€»æ˜¯ä½¿ç”¨UTF-8ç¼–ç 
                    finalEncoding = 'UTF-8';
                    const decoder = new TextDecoder('utf-8');
                    finalText = decoder.decode(buffer);
                    confidence = 100;
                } else {
                    // æ™®é€šæ–‡æœ¬æ–‡ä»¶ï¼Œä½¿ç”¨æ”¹è¿›çš„æ£€æµ‹ç®—æ³•
                    const detectionResult = detectEncoding(buffer);
                    const bestResult = tryDecodeWithMultipleEncodings(buffer);
                    
                    if (bestResult && bestResult.isValid) {
                        finalEncoding = bestResult.encoding;
                        finalText = bestResult.text;
                        confidence = Math.round((1 - bestResult.garbageRatio) * 100);
                    } else {
                        finalEncoding = detectionResult.encoding;
                        try {
                            const decoder = new TextDecoder(finalEncoding);
                            finalText = decoder.decode(buffer);
                            confidence = detectionResult.confidence;
                        } catch (e) {
                            finalEncoding = 'UTF-8';
                            const decoder = new TextDecoder('UTF-8');
                            finalText = decoder.decode(buffer);
                            confidence = 50;
                        }
                    }
                }
                
                fileContent = finalText;
                currentEncoding = finalEncoding;
                detectedEncoding = finalEncoding;
                
                updateProgress(80, 'æ­£åœ¨æ˜¾ç¤ºç»“æœ...');
                
                // æ›´æ–°ç¼–ç æç¤º
                let hintClass = 'encoding-auto';
                let hintMessage = '';
                
                if (isEncryptedFile) {
                    hintMessage = `ğŸ” åŠ å¯†æ–‡ä»¶ï¼Œä½¿ç”¨ UTF-8 ç¼–ç `;
                    hintClass = 'encoding-auto';
                } else if (confidence < 70) {
                    hintClass = '';
                    hintMessage = `âš ï¸ æ£€æµ‹åˆ°ç¼–ç : ${finalEncoding} (ç½®ä¿¡åº¦: ${confidence}%)ï¼Œè¯·ç¡®è®¤æ˜¯å¦æ­£ç¡®`;
                } else if (confidence >= 90) {
                    hintMessage = `ğŸ¯ æ£€æµ‹åˆ°ç¼–ç : ${finalEncoding} (ç½®ä¿¡åº¦: ${confidence}%)`;
                } else {
                    hintMessage = `âœ… æ£€æµ‹åˆ°ç¼–ç : ${finalEncoding} (ç½®ä¿¡åº¦: ${confidence}%)`;
                }
                
                encodingHint.innerHTML = hintMessage;
                encodingHint.className = `encoding-hint ${hintClass}`;
                
                // æ›´æ–°ç¼–ç é€‰æ‹©å™¨
                const encodingSelector = document.getElementById('encodingSelector');
                encodingSelector.value = finalEncoding;
                
                // æ›´æ–°æ–‡ä»¶ä¿¡æ¯
                updateFileInfo(currentFile);
                
                // æ˜¾ç¤ºé¢„è§ˆ
                const previewContent = fileContent.length > 1000 ? 
                    fileContent.substring(0, 1000) + '...' : fileContent;
                
                const fileContentElement = document.getElementById('fileContent');
                fileContentElement.value = previewContent;
                fileContentElement.style.display = 'block';
                
                const contentPreview = document.getElementById('contentPreview');
                contentPreview.style.display = 'block';
                contentPreview.textContent = `å†…å®¹é¢„è§ˆï¼ˆå‰${Math.min(1000, fileContent.length)}å­—ç¬¦ï¼‰:`;
                
                document.getElementById('fileEncryptBtn').disabled = false;
                document.getElementById('fileDecryptBtn').disabled = false;
                document.getElementById('fileAutoBtn').disabled = false;
                
                updateProgress(100, 'æ–‡ä»¶åŠ è½½å®Œæˆï¼');
                setTimeout(() => showProgress(false), 500);
                
                showNotification(`âœ… æ–‡ä»¶åŠ è½½å®Œæˆï¼${isEncryptedFile ? 'æ£€æµ‹åˆ°åŠ å¯†æ–‡ä»¶' : 'æ£€æµ‹ç¼–ç : ' + finalEncoding}`, 'success');
                
            } catch (error) {
                console.error('æ–‡ä»¶åˆ†æå¤±è´¥:', error);
                showNotification('âŒ æ–‡ä»¶åˆ†æå¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©ç¼–ç ', 'error');
                
                const contentTypeElement = document.getElementById('contentType');
                contentTypeElement.textContent = 'âŒ æ–‡ä»¶åˆ†æå¤±è´¥';
                contentTypeElement.className = 'content-type detected';
                
                const encodingHint = document.getElementById('encodingHint');
                encodingHint.innerHTML = 'âŒ è‡ªåŠ¨æ£€æµ‹å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©ç¼–ç ';
                encodingHint.className = 'encoding-hint';
                
                const encodingSelector = document.getElementById('encodingSelector');
                encodingSelector.value = '';
                
                showProgress(false);
            }
        }
        
        function applyEncoding(encoding) {
            if (!fileRawData || !encoding) return;
            
            try {
                const decoder = new TextDecoder(encoding);
                fileContent = decoder.decode(fileRawData);
                currentEncoding = encoding;
                
                // é‡æ–°æ£€æŸ¥æ˜¯å¦æ˜¯åŠ å¯†æ–‡ä»¶
                isEncryptedFile = isEncryptedText(fileContent);
                
                // æ›´æ–°é¢„è§ˆ
                const previewContent = fileContent.length > 1000 ? 
                    fileContent.substring(0, 1000) + '...' : fileContent;
                
                const fileContentElement = document.getElementById('fileContent');
                fileContentElement.value = previewContent;
                
                // æ›´æ–°æ–‡ä»¶ä¿¡æ¯
                updateFileInfo(currentFile);
                
                // æ›´æ–°ç¼–ç æç¤º
                const encodingHint = document.getElementById('encodingHint');
                if (isEncryptedFile) {
                    encodingHint.innerHTML = `ğŸ” åŠ å¯†æ–‡ä»¶ï¼Œå·²åº”ç”¨ç¼–ç : ${encoding}`;
                } else {
                    encodingHint.innerHTML = `âœ… å·²åº”ç”¨ç¼–ç : ${encoding}`;
                }
                encodingHint.className = 'encoding-hint encoding-auto';
                
                showNotification(`âœ… å·²åº”ç”¨ç¼–ç : ${encoding}`, 'success');
                
            } catch (error) {
                showNotification(`âŒ æ— æ³•ä½¿ç”¨ ${encoding} ç¼–ç è§£ç æ–‡ä»¶`, 'error');
            }
        }
        
        function updateFileInfo(file) {
            const fileInfo = document.getElementById('fileInfo');
            const fileName = document.getElementById('fileName');
            const fileSize = document.getElementById('fileSize');
            const charCount = document.getElementById('charCount');
            const byteCount = document.getElementById('byteCount');
            const detectedEncodingElement = document.getElementById('detectedEncoding');
            const fileTypeElement = document.getElementById('fileType');
            
            fileName.textContent = file.name;
            fileSize.textContent = formatFileSize(file.size);
            charCount.textContent = fileContent.length.toLocaleString();
            byteCount.textContent = (file.size / 1024).toFixed(0) + ' KB';
            detectedEncodingElement.textContent = currentEncoding;
            fileTypeElement.textContent = isEncryptedFile ? 'åŠ å¯†æ–‡ä»¶' : 'æ™®é€šæ–‡æœ¬';
            
            fileInfo.classList.add('show');
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        async function processFile(mode) {
            if (!currentFile || !fileContent) {
                showNotification('âŒ è¯·å…ˆä¸Šä¼ æ–‡ä»¶', 'error');
                return;
            }
            
            try {
                document.getElementById('fileEncryptBtn').disabled = true;
                document.getElementById('fileDecryptBtn').disabled = true;
                document.getElementById('fileAutoBtn').disabled = true;
                showProgress();
                
                const startTime = Date.now();
                let result;
                
                const fileSizeMB = (currentFile.size / 1024 / 1024).toFixed(1);
                showNotification(`ğŸ”„ æ­£åœ¨${mode === 'encrypt' ? 'åŠ å¯†' : 'è§£å¯†'} ${fileSizeMB}MB çš„æ–‡ä»¶...`, 'success');
                
                if (mode === 'encrypt') {
                    result = await aesEncryptLarge(fileContent, FIXED_KEY);
                } else {
                    if (!isEncryptedText(fileContent)) {
                        throw new Error('è¿™ä¸æ˜¯æœ‰æ•ˆçš„åŠ å¯†æ–‡æœ¬');
                    }
                    result = await aesDecryptLarge(fileContent, FIXED_KEY);
                }
                
                const endTime = Date.now();
                const processTime = ((endTime - startTime) / 1000).toFixed(2);
                
                showResult(result, mode, processTime, 'file');
                
                showNotification(`âœ… ${mode === 'encrypt' ? 'åŠ å¯†' : 'è§£å¯†'}æˆåŠŸï¼`, 'success');
                
            } catch (error) {
                console.error('å¤„ç†é”™è¯¯:', error);
                showNotification(`âŒ ${mode === 'encrypt' ? 'åŠ å¯†' : 'è§£å¯†'}å¤±è´¥ï¼š${error.message}`, 'error');
            } finally {
                document.getElementById('fileEncryptBtn').disabled = false;
                document.getElementById('fileDecryptBtn').disabled = false;
                document.getElementById('fileAutoBtn').disabled = false;
                showProgress(false);
            }
        }
        
        function autoProcessFile() {
            if (!currentFile || !fileContent) {
                showNotification('âŒ è¯·å…ˆä¸Šä¼ æ–‡ä»¶', 'error');
                return;
            }
            
            if (isEncryptedText(fileContent)) {
                processFile('decrypt');
            } else {
                processFile('encrypt');
            }
        }
        
        function clearFile() {
            currentFile = null;
            fileContent = '';
            fileRawData = null;
            currentEncoding = 'UTF-8';
            detectedEncoding = 'æœªçŸ¥';
            isEncryptedFile = false;
            
            document.getElementById('fileInput').value = '';
            document.getElementById('fileInfo').classList.remove('show');
            document.getElementById('fileContent').style.display = 'none';
            document.getElementById('fileContent').value = '';
            document.getElementById('contentPreview').style.display = 'none';
            document.getElementById('contentType').classList.remove('detected');
            document.getElementById('encodingContainer').classList.remove('show');
            document.getElementById('performanceWarning').classList.remove('show');
            document.getElementById('resultArea').classList.remove('show');
            document.getElementById('fileEncryptBtn').disabled = true;
            document.getElementById('fileDecryptBtn').disabled = true;
            document.getElementById('fileAutoBtn').disabled = true;
            
            document.getElementById('uploadArea').classList.remove('highlight');
            
            showNotification('ğŸ—‘ï¸ å·²æ¸…é™¤æ–‡ä»¶', 'success');
        }
        
        // ================= é€šç”¨åŠŸèƒ½ =================
        
        // function showResult(content, mode, processTime, inputMode) {
        //     document.getElementById('processType').textContent = mode === 'encrypt' ? 'åŠ å¯†' : 'è§£å¯†';
        //     document.getElementById('processTime').textContent = processTime + ' ç§’';
        //     document.getElementById('resultSize').textContent = content.length.toLocaleString() + ' å­—ç¬¦';
        //     document.getElementById('inputMode').textContent = inputMode === 'text' ? 'æ–‡æœ¬è¾“å…¥' : 'æ–‡ä»¶ä¸Šä¼ ';
            
        //     const resultContent = document.getElementById('resultContent');
        //     const previewText = content.length > 1000 ? 
        //         content.substring(0, 1000) + '...' : content;
        //     resultContent.textContent = previewText;
            
        //     const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
        //     const url = URL.createObjectURL(blob);
            
        //     const downloadLink = document.getElementById('downloadLink');
        //     downloadLink.href = url;
            
        //     let fileName = 'result.txt';
        //     if (inputMode === 'file' && currentFile) {
        //         const originalName = currentFile.name.replace('.txt', '');
        //         const timestamp = new Date().getTime();
        //         fileName = `${originalName}_${mode === 'encrypt' ? 'encrypted' : 'decrypted'}_${timestamp}.txt`;
        //     } else {
        //         const timestamp = new Date().getTime();
        //         fileName = `${mode === 'encrypt' ? 'encrypted' : 'decrypted'}_${timestamp}.txt`;
        //     }
            
        //     downloadLink.download = fileName;
        //     downloadLink.textContent = `â¬‡ï¸ ä¸‹è½½ ${fileName}`;
            
        //     const copyBtn = document.getElementById('copyResultBtn');
        //     copyBtn.textContent = 'ğŸ“‹ å¤åˆ¶ç»“æœ';
        //     copyBtn.classList.remove('copied');
            
        //     const resultArea = document.getElementById('resultArea');
        //     resultArea.classList.add('show');
            
        //     resultArea.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        // }
        function showResult(content, mode, processTime, inputMode) {
            document.getElementById('processType').textContent = mode === 'encrypt' ? 'åŠ å¯†' : 'è§£å¯†';
            document.getElementById('processTime').textContent = processTime + ' ç§’';
            document.getElementById('resultSize').textContent = content.length.toLocaleString() + ' å­—ç¬¦';
            document.getElementById('inputMode').textContent = inputMode === 'text' ? 'æ–‡æœ¬è¾“å…¥' : 'æ–‡ä»¶ä¸Šä¼ ';
            
            const resultContent = document.getElementById('resultContent');
            
            // æ ¹æ®è¾“å…¥æ¨¡å¼å†³å®šæ˜¾ç¤ºæ–¹å¼
            if (inputMode === 'text') {
                // === ä¿®æ”¹è¿™é‡Œï¼šæ–‡æœ¬æ¨¡å¼æ˜¾ç¤ºå…¨éƒ¨å†…å®¹ ===
                resultContent.textContent = content;  // ç›´æ¥æ˜¾ç¤ºå®Œæ•´å†…å®¹
                
            } else {
                // æ–‡ä»¶æ¨¡å¼ï¼šåªæ˜¾ç¤ºå‰1000å­—ç¬¦é¢„è§ˆï¼ˆä¿æŒä¸å˜ï¼‰
                const previewText = content.length > 1000 ? 
                    content.substring(0, 1000) + '...' : content;
                resultContent.textContent = previewText;
            }
            
            // å…¶ä»–ä»£ç ä¿æŒä¸å˜...
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const downloadLink = document.getElementById('downloadLink');
            downloadLink.href = url;
            
            let fileName = 'result.txt';
            if (inputMode === 'file' && currentFile) {
                const originalName = currentFile.name.replace('.txt', '');
                const timestamp = new Date().getTime();
                fileName = `${originalName}_${mode === 'encrypt' ? 'encrypted' : 'decrypted'}_${timestamp}.txt`;
            } else {
                const timestamp = new Date().getTime();
                fileName = `${mode === 'encrypt' ? 'encrypted' : 'decrypted'}_${timestamp}.txt`;
            }
            
            downloadLink.download = fileName;
            downloadLink.textContent = `â¬‡ï¸ ä¸‹è½½ ${fileName}`;
            
            const copyBtn = document.getElementById('copyResultBtn');
            copyBtn.textContent = 'ğŸ“‹ å¤åˆ¶ç»“æœ';
            copyBtn.classList.remove('copied');
            
            const resultArea = document.getElementById('resultArea');
            resultArea.classList.add('show');
            
            resultArea.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        function copyResult() {
            const resultText = document.getElementById('resultContent').textContent;
            
            if (!resultText) {
                showNotification('æ²¡æœ‰å†…å®¹å¯å¤åˆ¶', 'warning');
                return;
            }
            
            navigator.clipboard.writeText(resultText)
                .then(() => {
                    const copyBtn = document.getElementById('copyResultBtn');
                    copyBtn.textContent = 'âœ“ å·²å¤åˆ¶';
                    copyBtn.classList.add('copied');
                    
                    setTimeout(() => {
                        copyBtn.textContent = 'ğŸ“‹ å¤åˆ¶ç»“æœ';
                        copyBtn.classList.remove('copied');
                    }, 2000);
                    
                    showNotification('âœ… ç»“æœå·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼', 'success');
                })
                .catch(err => {
                    showNotification('âŒ å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©å¤åˆ¶', 'error');
                });
        }
        
        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            initDragAndDrop();
            
            const exampleText = `è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹æ–‡æœ¬ã€‚

åŠ å¯†è§£å¯†æµ‹è¯•ã€‚

æ”¯æŒä¸­æ–‡ã€è‹±æ–‡ã€æ•°å­—å’Œç¬¦å·ï¼š!@#$%^&*()

è¯•è¯•åŠ å¯†è¿™æ®µæ–‡æœ¬ï¼Œç„¶åè§£å¯†çœ‹çœ‹æ•ˆæœå¦‚ä½•ï¼Ÿ`;
            
            document.getElementById('textInput').value = exampleText;
            
            document.addEventListener('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
                    e.preventDefault();
                    if (currentMode === 'text') {
                        processText('encrypt');
                    } else {
                        processFile('encrypt');
                    }
                }
                if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
                    e.preventDefault();
                    if (currentMode === 'text') {
                        processText('decrypt');
                    } else {
                        processFile('decrypt');
                    }
                }
                if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                    e.preventDefault();
                    if (currentMode === 'text') {
                        autoProcessText();
                    } else {
                        autoProcessFile();
                    }
                }
                if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
                    e.preventDefault();
                    if (currentMode === 'text') {
                        clearText();
                    } else {
                        clearFile();
                    }
                }
            });
            
            const capacityInfo = document.querySelector('.capacity-info');
            const hint = document.createElement('div');
            hint.innerHTML = '<small>å¿«æ·é”®ï¼šCtrl+E=åŠ å¯†ï¼ŒCtrl+D=è§£å¯†ï¼ŒCtrl+A=è‡ªåŠ¨ï¼ŒCtrl+R=æ¸…é™¤</small>';
            hint.style.marginTop = '5px';
            hint.style.fontSize = '14px';
            hint.style.opacity = '0.9';
            capacityInfo.appendChild(hint);
        });
    </script>
</body>
</html>
